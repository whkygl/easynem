result = method(data, .group, y, ...)
return(result)
}
KruskalTest <- function(data, .group, y, ...){
.compare = methods::new("compare")
meta = as.data.frame(data@meta)
meta = meta[,c(1, which(names(meta) %in% c(.group, y)))]
row.names(meta) = meta[,1]
result = stats::kruskal.test(meta[[y]]~meta[[.group]], data = meta, ...)
.compare@result = result
.compare@meta = meta
.compare@temp = c("KruskalTest")
return(.compare)
}
hehe <- calc_compare(bac, con_crop, pH, method = KruskalTest)
hehe
hehe$wkg = "hehe"
hehe@result$wkg = "hehe"
hehe
source("http://www.statmethods.net/RiA/wmc.txt")
states <- data.frame(state.region, state.x77)
View(states)
wmc(Illiteracy ~ state.region, data=states, method="holm")
View(states)
formula = Illiteracy ~ state.region
data = states
exact=FALSE
sort=TRUE
method="holm"
# setup
df <- model.frame(formula, data)
y <- df[[1]]
x <- as.factor(df[[2]])
# reorder levels of x by median y
if(sort){
medians <- aggregate(y, by=list(x), FUN=median)[2]
index <- order(medians)
x <- factor(x, levels(x)[index])
}
medians <- aggregate(y, by=list(x), FUN=median)[2]
index <- order(medians)
View(medians)
index <- order(medians)
View(medians)
medians <- as.vector(medians)
index <- order(medians)
x <- factor(x, levels(x)[index])
wmc <- function(formula, data, exact=FALSE, sort=TRUE, method="holm"){
formula = Illiteracy ~ state.region
data = states
# setup
df <- model.frame(formula, data)
y <- df[[1]]
x <- as.factor(df[[2]])
# reorder levels of x by median y
if(sort){
medians <- aggregate(y, by=list(x), FUN=median)[2]
medians <- as.vector(medians)
index <- order(medians)
x <- factor(x, levels(x)[index])
}
groups <- levels(x)
k <- length(groups)
# summary statistics
stats <- function(z)(c(N = length(z), Median = median(z), MAD = mad(z)))
sumstats <- t(aggregate(y, by=list(x), FUN=stats)[2])
rownames(sumstats) <- c("n", "median", "mad")
colnames(sumstats) <- groups
cat("Descriptive Statistics\n\n")
print(sumstats)
# multiple comparisons
mc <- data.frame(Group.1=character(0),
Group.2=character(0),
W=numeric(0),
p.unadj=numeric(0),
p=numeric(0),
stars=character(0),
stringsAsFactors=FALSE)
# perform Wilcoxon test
row <- 0
for(i in 1:k){
for(j in 1:k){
if (j > i){
row <- row + 1
y1 <- y[x==groups[i]]
y2 <- y[x==groups[j]]
test <- wilcox.test(y1, y2, exact=exact)
mc[row,1] <- groups[i]
mc[row,2] <- groups[j]
mc[row,3] <- test$statistic
mc[row,4] <- test$p.value
}
}
}
mc$p <- p.adjust(mc$p.unadj, method=method)
# add stars
mc$stars <- " "
mc$stars[mc$p <   .1] <- "."
mc$stars[mc$p <  .05] <- "*"
mc$stars[mc$p <  .01] <- "**"
mc$stars[mc$p < .001] <- "***"
names(mc)[6] <- " "
cat("\nMultiple Comparisons (Wilcoxon Rank Sum Tests)\n")
cat(paste("Probability Adjustment = ", method, "\n\n", sep=""))
print(mc[-4], right=TRUE)
cat("---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n")
return(invisible(NULL))
}
wmc(Illiteracy ~ state.region, data=states, method="holm")
formula = Illiteracy ~ state.region
data = states
# setup
df <- model.frame(formula, data)
y <- df[[1]]
x <- as.factor(df[[2]])
# reorder levels of x by median y
if(sort){
medians <- aggregate(y, by=list(x), FUN=median)[2]
medians <- as.vector(medians)
index <- order(medians)
x <- factor(x, levels(x)[index])
}
groups <- levels(x)
k <- length(groups)
# summary statistics
stats <- function(z)(c(N = length(z), Median = median(z), MAD = mad(z)))
sumstats <- t(aggregate(y, by=list(x), FUN=stats)[2])
rownames(sumstats) <- c("n", "median", "mad")
colnames(sumstats) <- groups
cat("Descriptive Statistics\n\n")
print(sumstats)
# multiple comparisons
mc <- data.frame(Group.1=character(0),
Group.2=character(0),
W=numeric(0),
p.unadj=numeric(0),
p=numeric(0),
stars=character(0),
stringsAsFactors=FALSE)
# perform Wilcoxon test
row <- 0
for(i in 1:k){
for(j in 1:k){
if (j > i){
row <- row + 1
y1 <- y[x==groups[i]]
y2 <- y[x==groups[j]]
test <- wilcox.test(y1, y2, exact=exact)
mc[row,1] <- groups[i]
mc[row,2] <- groups[j]
mc[row,3] <- test$statistic
mc[row,4] <- test$p.value
}
}
}
mc$p <- p.adjust(mc$p.unadj, method=method)
# add stars
mc$stars <- " "
mc$stars[mc$p <   .1] <- "."
View(mc)
wmc <- function(formula, data, exact=FALSE, sort=TRUE, method="holm"){
formula = Illiteracy ~ state.region
data = states
# setup
df <- model.frame(formula, data)
y <- df[[1]]
x <- as.factor(df[[2]])
# reorder levels of x by median y
if(sort){
medians <- aggregate(y, by=list(x), FUN=median)[2]
medians2 <- as.vector(medians2)
index <- order(medians2)
x <- factor(x, levels(x)[index])
}
groups <- levels(x)
k <- length(groups)
# summary statistics
stats <- function(z)(c(N = length(z), Median = median(z), MAD = mad(z)))
sumstats <- t(aggregate(y, by=list(x), FUN=stats)[2])
rownames(sumstats) <- c("n", "median", "mad")
colnames(sumstats) <- groups
cat("Descriptive Statistics\n\n")
print(sumstats)
# multiple comparisons
mc <- data.frame(Group.1=character(0),
Group.2=character(0),
W=numeric(0),
p.unadj=numeric(0),
p=numeric(0),
stars=character(0),
stringsAsFactors=FALSE)
# perform Wilcoxon test
row <- 0
for(i in 1:k){
for(j in 1:k){
if (j > i){
row <- row + 1
y1 <- y[x==groups[i]]
y2 <- y[x==groups[j]]
test <- wilcox.test(y1, y2, exact=exact)
mc[row,1] <- groups[i]
mc[row,2] <- groups[j]
mc[row,3] <- test$statistic
mc[row,4] <- test$p.value
}
}
}
mc$p <- p.adjust(mc$p.unadj, method=method)
# add stars
mc$stars <- " "
mc$stars[mc$p <   .1] <- "."
mc$stars[mc$p <  .05] <- "*"
mc$stars[mc$p <  .01] <- "**"
mc$stars[mc$p < .001] <- "***"
names(mc)[6] <- " "
cat("\nMultiple Comparisons (Wilcoxon Rank Sum Tests)\n")
cat(paste("Probability Adjustment = ", method, "\n\n", sep=""))
print(mc[-4], right=TRUE)
cat("---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n")
return(invisible(NULL))
}
wmc(Illiteracy ~ state.region, data=states, method="holm")
wmc <- function(formula, data, exact=FALSE, sort=TRUE, method="holm"){
formula = Illiteracy ~ state.region
data = states
# setup
df <- model.frame(formula, data)
y <- df[[1]]
x <- as.factor(df[[2]])
# reorder levels of x by median y
if(sort){
medians <- aggregate(y, by=list(x), FUN=median)[2]
medians2 <- as.vector(medians)
index <- order(medians2)
x <- factor(x, levels(x)[index])
}
groups <- levels(x)
k <- length(groups)
# summary statistics
stats <- function(z)(c(N = length(z), Median = median(z), MAD = mad(z)))
sumstats <- t(aggregate(y, by=list(x), FUN=stats)[2])
rownames(sumstats) <- c("n", "median", "mad")
colnames(sumstats) <- groups
cat("Descriptive Statistics\n\n")
print(sumstats)
# multiple comparisons
mc <- data.frame(Group.1=character(0),
Group.2=character(0),
W=numeric(0),
p.unadj=numeric(0),
p=numeric(0),
stars=character(0),
stringsAsFactors=FALSE)
# perform Wilcoxon test
row <- 0
for(i in 1:k){
for(j in 1:k){
if (j > i){
row <- row + 1
y1 <- y[x==groups[i]]
y2 <- y[x==groups[j]]
test <- wilcox.test(y1, y2, exact=exact)
mc[row,1] <- groups[i]
mc[row,2] <- groups[j]
mc[row,3] <- test$statistic
mc[row,4] <- test$p.value
}
}
}
mc$p <- p.adjust(mc$p.unadj, method=method)
# add stars
mc$stars <- " "
mc$stars[mc$p <   .1] <- "."
mc$stars[mc$p <  .05] <- "*"
mc$stars[mc$p <  .01] <- "**"
mc$stars[mc$p < .001] <- "***"
names(mc)[6] <- " "
cat("\nMultiple Comparisons (Wilcoxon Rank Sum Tests)\n")
cat(paste("Probability Adjustment = ", method, "\n\n", sep=""))
print(mc[-4], right=TRUE)
cat("---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n")
return(invisible(NULL))
}
wmc(Illiteracy ~ state.region, data=states, method="holm")
formula = Illiteracy ~ state.region
data = states
# setup
df <- model.frame(formula, data)
y <- df[[1]]
x <- as.factor(df[[2]])
# reorder levels of x by median y
if(sort){
medians <- aggregate(y, by=list(x), FUN=median)[2]
medians2 <- as.vector(medians)
index <- order(medians2)
x <- factor(x, levels(x)[index])
}
groups <- levels(x)
k <- length(groups)
# summary statistics
stats <- function(z)(c(N = length(z), Median = median(z), MAD = mad(z)))
sumstats <- t(aggregate(y, by=list(x), FUN=stats)[2])
rownames(sumstats) <- c("n", "median", "mad")
colnames(sumstats) <- groups
cat("Descriptive Statistics\n\n")
print(sumstats)
# multiple comparisons
mc <- data.frame(Group.1=character(0),
Group.2=character(0),
W=numeric(0),
p.unadj=numeric(0),
p=numeric(0),
stars=character(0),
stringsAsFactors=FALSE)
# perform Wilcoxon test
row <- 0
for(i in 1:k){
for(j in 1:k){
if (j > i){
row <- row + 1
y1 <- y[x==groups[i]]
y2 <- y[x==groups[j]]
test <- wilcox.test(y1, y2, exact=exact)
mc[row,1] <- groups[i]
mc[row,2] <- groups[j]
mc[row,3] <- test$statistic
mc[row,4] <- test$p.value
}
}
}
mc$p <- p.adjust(mc$p.unadj, method=method)
View(mc)
# add stars
mc$stars <- " "
mc$stars[mc$p <   .1] <- "."
mc$stars[mc$p <  .05] <- "*"
mc$stars[mc$p <  .01] <- "**"
mc$stars[mc$p < .001] <- "***"
names(mc)[6] <- " "
cat("\nMultiple Comparisons (Wilcoxon Rank Sum Tests)\n")
cat(paste("Probability Adjustment = ", method, "\n\n", sep=""))
print(mc[-4], right=TRUE)
cat("---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n")
return(invisible(NULL))
formula = Illiteracy ~ state.region
data = states
# setup
df <- model.frame(formula, data)
y <- df[[1]]
x <- as.factor(df[[2]])
# reorder levels of x by median y
if(sort){
medians <- aggregate(y, by=list(x), FUN=median)[2]
index <- order(medians)
x <- factor(x, levels(x)[index])
}
medians <- aggregate(y, by=list(x), FUN=median)[2]
View(medians)
index <- order(medians)
?order
index <- order(table = medians)
View(medians)
index <- order(as.vector(medians))
index
as.vector(medians)
index <- order(as.vector(medians$x))
index
x <- factor(x, levels(x)[index])
x
wmc <- function(formula, data, exact=FALSE, sort=TRUE, method="holm"){
formula = Illiteracy ~ state.region
data = states
# setup
df <- model.frame(formula, data)
y <- df[[1]]
x <- as.factor(df[[2]])
# reorder levels of x by median y
if(sort){
medians <- aggregate(y, by=list(x), FUN=median)[2]
index <- order(as.vector(medians$x))
x <- factor(x, levels(x)[index])
}
groups <- levels(x)
k <- length(groups)
# summary statistics
stats <- function(z)(c(N = length(z), Median = median(z), MAD = mad(z)))
sumstats <- t(aggregate(y, by=list(x), FUN=stats)[2])
rownames(sumstats) <- c("n", "median", "mad")
colnames(sumstats) <- groups
cat("Descriptive Statistics\n\n")
print(sumstats)
# multiple comparisons
mc <- data.frame(Group.1=character(0),
Group.2=character(0),
W=numeric(0),
p.unadj=numeric(0),
p=numeric(0),
stars=character(0),
stringsAsFactors=FALSE)
# perform Wilcoxon test
row <- 0
for(i in 1:k){
for(j in 1:k){
if (j > i){
row <- row + 1
y1 <- y[x==groups[i]]
y2 <- y[x==groups[j]]
test <- wilcox.test(y1, y2, exact=exact)
mc[row,1] <- groups[i]
mc[row,2] <- groups[j]
mc[row,3] <- test$statistic
mc[row,4] <- test$p.value
}
}
}
mc$p <- p.adjust(mc$p.unadj, method=method)
# add stars
mc$stars <- " "
mc$stars[mc$p <   .1] <- "."
mc$stars[mc$p <  .05] <- "*"
mc$stars[mc$p <  .01] <- "**"
mc$stars[mc$p < .001] <- "***"
names(mc)[6] <- " "
cat("\nMultiple Comparisons (Wilcoxon Rank Sum Tests)\n")
cat(paste("Probability Adjustment = ", method, "\n\n", sep=""))
print(mc[-4], right=TRUE)
cat("---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n")
return(invisible(NULL))
}
wmc(Illiteracy ~ state.region, data=states, method="holm")
install.packages("npar")
??npar
# Install the npar package
pkg <- "npar_1.0.tar.gz"
loc <- "http://www.statmethods.net/RiA"
url <- paste(loc, pkg, sep="/")
download.file(url, pkg)
install.packages(pkg, repos=NULL, type="source")
# Explore the life dataset
library(npar)
hist(life$hlef, xlab="Healthy Life Expectacy (years) at Age 65",
main="Distribution of Healthy Life Expectancy for Women",
col="grey", breaks=10)
dotchart(hlef ~ region, life, col="darkgrey", vertical=TRUE,
xlab="US Region",
ylab="Healthy Life Expectancy (years) at Age 65",
main="Distribution of HLE Estimates by Region")
# Listing 21.1 - Comparison of HLE estimates with the npar package
results <- oneway(hlef ~ region, life)
summary(results)
plot(results, col="lightblue", main="Multiple Comparisons",
xlab="US Region",
ylab="Healthy Life Expectancy (years) at Age 65")
rm(list = ls())
library(easynem)
bac <- read_nem(tab = easynem_example("bacotu.csv"), tax = easynem_example("bactax.csv"), meta = easynem_example("meta.csv"))
calc_compare <- function(data, .group, y, method, ...){
.group = deparse(substitute(.group))
y = deparse(substitute(y))
result = method(data, .group, y, ...)
return(result)
}
KruskalTest <- function(data, .group, y, exact=FALSE, sort=TRUE,
.method=c("holm", "hochberg", "hommel", "bonferroni",
"BH", "BY", "fdr", "none"), ...){
.compare = methods::new("compare")
y2 = y
meta = as.data.frame(data@meta)
meta = meta[,c(1, which(names(meta) %in% c(.group, y)))]
row.names(meta) = meta[,1]
method <- match.arg(.method)
df = meta
y <- df[[3]]
g <- as.factor(df[[2]])
vnames <- names(df)
if(sort) g <- reorder(g, y, FUN=median)
groups <- levels(g)
k <- nlevels(g)
getstats <- function(x)(c(N = length(x), Median = median(x),
MAD = mad(x)))
sumstats <- t(aggregate(y, by=list(g), FUN=getstats)[2])
rownames(sumstats) <- c("n", "median", "mad")
colnames(sumstats) <- groups
kw <- stats::kruskal.test(meta[[y2]]~meta[[.group]], data=meta, ...)
wmc <- NULL
for (i in 1:(k-1)){
for (j in (i+1):k){
y1 <- y[g==groups[i]]
y2 <- y[g==groups[j]]
test <- wilcox.test(y1, y2, exact=exact)
r <- data.frame(Group.1=groups[i], Group.2=groups[j],
W=test$statistic[[1]], p=test$p.value)
# note the [[]] to return a single number
wmc <- rbind(wmc, r)
}
}
wmc$p <- p.adjust(wmc$p, method=method)
data <- data.frame(y, g)
names(data) <- c(vnames[3],vnames[2])
results <- list(CALL = match.call(),
data=data,
sumstats=sumstats, kw=kw,
method=method, wmc=wmc, vnames=vnames)
.compare@result = results
.compare@meta = meta
.compare@temp = c("KruskalTest")
return(.compare)
}
hehe <- calc_compare(bac, con_crop, pH, method = KruskalTest)
hehe
View(hehe)
hehe@result$wmc
