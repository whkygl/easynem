} else if (type == 'nmds'){
utils::capture.output(df_nmds <-  vegan::metaMDS(dist, k = 3))
stress = df_nmds$stress
nmds_points = as.data.frame(df_nmds$points)
names(nmds_points)[1:2] <- c('NMDS1', 'NMDS2')
inter = intersect(rownames(meta), rownames(nmds_points))
meta = meta[inter,]
nmds_points = nmds_points[inter,]
nmds_result = cbind(meta, nmds_points)
adonis = paste('Stress=',round(stress, 3))
.beta@temp = adonis
.beta@meta = tibble::as_tibble(nmds_result)
} else if (type == 'pca'){
pca = stats::prcomp(otu2, ...)
formula_str = paste("otu2~", .group)
formula_obj = stats::as.formula(formula_str)
div = vegan::adonis2(formula_obj, data = meta, permutations = 999, ...)
adonis = paste0("Adonis: R=",round(div$R2,3), "; p=",div$`Pr(>F)`)
pca_points = as.data.frame(pca$x)
inter = intersect(rownames(meta), rownames(pca_points))
meta = meta[inter,]
pca_points = pca_points[inter,]
pca_result = cbind(meta, pca_points)
summ1 = summary(pca)
x = paste0("PCA1(",round(summ1$importance[2,1]*100,2),"%)")
y = paste0("PCA2(",round(summ1$importance[2,2]*100,2),"%)")
temp = c(x, y, adonis)
.beta@temp = temp
.beta@meta = tibble::as_tibble(pca_result)
} else{
stop("type should be one of 'pcoa', 'nmds' and 'pca'")
}
# pair_adonis = pairwiseAdonis::pairwise.adonis(x=otu2,
#                                               factors = meta[[.group]],
#                                               p.adjust.m = "none",
#                                               sim.method = method)
# sig = tibble::as_tibble(pair_adonis)
# sig = dplyr::mutate(sig, sig = dplyr::case_when(
#   p.adjusted >= 0.1 ~ "ns",
#   p.adjusted > 0.05 & p.adjusted < 0.1 ~ ".",
#   p.adjusted > 0.01 & p.adjusted <= 0.05 ~ "*",
#   p.adjusted > 0.001 & p.adjusted <= 0.01 ~ "**",
#   p.adjusted > 0.0001 & p.adjusted <= 0.001 ~ "***",
#   p.adjusted <= 0.0001 ~ "****"
# ))
# .beta@result = sig
# return(.beta)
}
nem_pcoa <- nem |> calc_beta(pcoa, Treatments, method = "bray")
nem_pcoa
#' \code{\link{calc_ter}}, \code{\link{calc_ter2}}, \code{\link{calc_ef}},
#' \code{\link{calc_ef2}}.
#'
#' @export
#' @examples
#' nem <- read_nem2(tab = nemtab, tax = nemtax, meta = nemmeta)
#' nem_pcoa <- nem |> calc_beta(pcoa, Treatments, method = "bray")
#' show(nem_pcoa)
#' nem_nmds <- nem |> calc_beta(nmds, Treatments, method = "bray")
#' show(nem_nmds)
calc_beta <- function(data, type, .group, method, ...){
p_list = c("pairwiseAdonis")
for (p in p_list) {
if (!requireNamespace(p)) {
remotes::install_github(p)
}
}
type = deparse(substitute(type))
.group = deparse(substitute(.group))
method = deparse(substitute(method))
.beta = methods::new("beta")
otu = as.data.frame(data@tab)
row.names(otu) = otu[,1]
otu = otu[,-1]
otu2 = t(otu)
meta = as.data.frame(data@meta)
meta = meta[,c(1, which(names(meta) == .group))]
row.names(meta) = meta[,1]
dist = vegan::vegdist(t(otu), binary = FALSE, scale= TRUE,center = TRUE, ...)
if (type == 'pcoa'){
pcoa = stats::cmdscale(dist, k = 3, eig =TRUE, ...)
pcoa_points = as.data.frame(pcoa$points)
sum_eig = sum(pcoa$eig)
eig_percent = round(pcoa$eig/sum_eig*100,1)
colnames(pcoa_points) <- paste0("PCoA", 1:3)
inter = intersect(rownames(meta), rownames(pcoa_points))
meta = meta[inter,]
pcoa_points = pcoa_points[inter,]
pcoa_result = cbind(meta, pcoa_points)
x=paste("PCoA 1 (", eig_percent[1], "%)", sep="")
y=paste("PCoA 2 (", eig_percent[2], "%)", sep="")
formula_str = paste("otu2~", .group)
formula_obj = stats::as.formula(formula_str)
div = vegan::adonis2(formula_obj, data = meta, permutations = 999, ...)
adonis = paste0("Adonis: R=",round(div$R2,3), "; p=",div$`Pr(>F)`)
temp = c(x,y,adonis)
.beta@temp = temp
.beta@meta = tibble::as_tibble(pcoa_result)
} else if (type == 'nmds'){
utils::capture.output(df_nmds <-  vegan::metaMDS(dist, k = 3))
stress = df_nmds$stress
nmds_points = as.data.frame(df_nmds$points)
names(nmds_points)[1:2] <- c('NMDS1', 'NMDS2')
inter = intersect(rownames(meta), rownames(nmds_points))
meta = meta[inter,]
nmds_points = nmds_points[inter,]
nmds_result = cbind(meta, nmds_points)
adonis = paste('Stress=',round(stress, 3))
.beta@temp = adonis
.beta@meta = tibble::as_tibble(nmds_result)
} else if (type == 'pca'){
pca = stats::prcomp(otu2, ...)
formula_str = paste("otu2~", .group)
formula_obj = stats::as.formula(formula_str)
div = vegan::adonis2(formula_obj, data = meta, permutations = 999, ...)
adonis = paste0("Adonis: R=",round(div$R2,3), "; p=",div$`Pr(>F)`)
pca_points = as.data.frame(pca$x)
inter = intersect(rownames(meta), rownames(pca_points))
meta = meta[inter,]
pca_points = pca_points[inter,]
pca_result = cbind(meta, pca_points)
summ1 = summary(pca)
x = paste0("PCA1(",round(summ1$importance[2,1]*100,2),"%)")
y = paste0("PCA2(",round(summ1$importance[2,2]*100,2),"%)")
temp = c(x, y, adonis)
.beta@temp = temp
.beta@meta = tibble::as_tibble(pca_result)
} else{
stop("type should be one of 'pcoa', 'nmds' and 'pca'")
}
pair_adonis = pairwiseAdonis::pairwise.adonis(x=otu2,
factors = meta[[.group]],
p.adjust.m = "none",
sim.method = "bray")
sig = tibble::as_tibble(pair_adonis)
sig = dplyr::mutate(sig, sig = dplyr::case_when(
p.adjusted >= 0.1 ~ "ns",
p.adjusted > 0.05 & p.adjusted < 0.1 ~ ".",
p.adjusted > 0.01 & p.adjusted <= 0.05 ~ "*",
p.adjusted > 0.001 & p.adjusted <= 0.01 ~ "**",
p.adjusted > 0.0001 & p.adjusted <= 0.001 ~ "***",
p.adjusted <= 0.0001 ~ "****"
))
.beta@result = sig
return(.beta)
}
nem_pcoa <- nem |> calc_beta(pcoa, Treatments, method = "bray")
nem_pcoa
nem_pcoa <- easynem|> calc_beta(pcoa, con_crop, method = "bray")
nem_pcoa
nem_pcoa <- nem |> calc_beta(pcoa, Treatments, method = "bray")
nem_pcoa
#' \code{\link{calc_ter}}, \code{\link{calc_ter2}}, \code{\link{calc_ef}},
#' \code{\link{calc_ef2}}.
#'
#' @export
#' @examples
#' nem <- read_nem2(tab = nemtab, tax = nemtax, meta = nemmeta)
#' nem_pcoa <- nem |> calc_beta(pcoa, Treatments, method = "bray")
#' show(nem_pcoa)
#' nem_nmds <- nem |> calc_beta(nmds, Treatments, method = "bray")
#' show(nem_nmds)
calc_beta <- function(data, type, .group, method, ...){
p_list = c("pairwiseAdonis")
for (p in p_list) {
if (!requireNamespace(p)) {
remotes::install_github(p)
}
}
type = deparse(substitute(type))
.group = deparse(substitute(.group))
method = deparse(substitute(method))
.beta = methods::new("beta")
otu = as.data.frame(data@tab)
row.names(otu) = otu[,1]
otu = otu[,-1]
otu2 = t(otu)
meta = as.data.frame(data@meta)
meta = meta[,c(1, which(names(meta) == .group))]
row.names(meta) = meta[,1]
dist = vegan::vegdist(t(otu), binary = FALSE, scale= TRUE,center = TRUE, ...)
if (type == 'pcoa'){
pcoa = stats::cmdscale(dist, k = 3, eig =TRUE, ...)
pcoa_points = as.data.frame(pcoa$points)
sum_eig = sum(pcoa$eig)
eig_percent = round(pcoa$eig/sum_eig*100,1)
colnames(pcoa_points) <- paste0("PCoA", 1:3)
inter = intersect(rownames(meta), rownames(pcoa_points))
meta = meta[inter,]
pcoa_points = pcoa_points[inter,]
pcoa_result = cbind(meta, pcoa_points)
x=paste("PCoA 1 (", eig_percent[1], "%)", sep="")
y=paste("PCoA 2 (", eig_percent[2], "%)", sep="")
formula_str = paste("otu2~", .group)
formula_obj = stats::as.formula(formula_str)
div = vegan::adonis2(formula_obj, data = meta, permutations = 999, ...)
adonis = paste0("Adonis: R=",round(div$R2,3), "; p=",div$`Pr(>F)`)
temp = c(x,y,adonis)
.beta@temp = temp
.beta@meta = tibble::as_tibble(pcoa_result)
.beta@result = adonis
} else if (type == 'nmds'){
utils::capture.output(df_nmds <-  vegan::metaMDS(dist, k = 3))
stress = df_nmds$stress
nmds_points = as.data.frame(df_nmds$points)
names(nmds_points)[1:2] <- c('NMDS1', 'NMDS2')
inter = intersect(rownames(meta), rownames(nmds_points))
meta = meta[inter,]
nmds_points = nmds_points[inter,]
nmds_result = cbind(meta, nmds_points)
adonis = paste('Stress=',round(stress, 3))
.beta@temp = adonis
.beta@meta = tibble::as_tibble(nmds_result)
.beta@result = adonis
} else if (type == 'pca'){
pca = stats::prcomp(otu2, ...)
formula_str = paste("otu2~", .group)
formula_obj = stats::as.formula(formula_str)
div = vegan::adonis2(formula_obj, data = meta, permutations = 999, ...)
adonis = paste0("Adonis: R=",round(div$R2,3), "; p=",div$`Pr(>F)`)
pca_points = as.data.frame(pca$x)
inter = intersect(rownames(meta), rownames(pca_points))
meta = meta[inter,]
pca_points = pca_points[inter,]
pca_result = cbind(meta, pca_points)
summ1 = summary(pca)
x = paste0("PCA1(",round(summ1$importance[2,1]*100,2),"%)")
y = paste0("PCA2(",round(summ1$importance[2,2]*100,2),"%)")
temp = c(x, y, adonis)
.beta@temp = temp
.beta@meta = tibble::as_tibble(pca_result)
.beta@result = adonis
} else{
stop("type should be one of 'pcoa', 'nmds' and 'pca'")
}
return(.beta)
}
nem_pcoa <- nem |> calc_beta(pcoa, Treatments, method = "bray")
#' @slot temp A character vector of the difference comparison.
#'
#' @seealso
#' The constructor, \code{\link{calc_beta}}; Class for storing two-factor beta
#' diversity analysis, \code{\link{beta2-class}}; Visualization function,
#' \code{\link{nem_plot}}.
#'
#' @name beta-class
#' @rdname beta-class
#' @exportClass beta
methods::setClass("beta",
slots = list(
meta = "data.frame",
result = "character",
temp = "character"
))
methods::setMethod("show", "beta", function(object){
cat("This is an beta object\n")
cat("The difference comparison is:\n")
print(object@result)
})
nem_pcoa <- nem |> calc_beta(pcoa, Treatments, method = "bray")
nem_pcoa
adonis[1]
#' \code{\link{calc_ter}}, \code{\link{calc_ter2}}, \code{\link{calc_ef}},
#' \code{\link{calc_ef2}}.
#'
#' @export
#' @examples
#' nem <- read_nem2(tab = nemtab, tax = nemtax, meta = nemmeta)
#' nem_pcoa <- nem |> calc_beta(pcoa, Treatments, method = "bray")
#' show(nem_pcoa)
#' nem_nmds <- nem |> calc_beta(nmds, Treatments, method = "bray")
#' show(nem_nmds)
calc_beta <- function(data, type, .group, method, ...){
p_list = c("pairwiseAdonis")
for (p in p_list) {
if (!requireNamespace(p)) {
remotes::install_github(p)
}
}
type = deparse(substitute(type))
.group = deparse(substitute(.group))
method = deparse(substitute(method))
.beta = methods::new("beta")
otu = as.data.frame(data@tab)
row.names(otu) = otu[,1]
otu = otu[,-1]
otu2 = t(otu)
meta = as.data.frame(data@meta)
meta = meta[,c(1, which(names(meta) == .group))]
row.names(meta) = meta[,1]
dist = vegan::vegdist(t(otu), binary = FALSE, scale= TRUE,center = TRUE, ...)
if (type == 'pcoa'){
pcoa = stats::cmdscale(dist, k = 3, eig =TRUE, ...)
pcoa_points = as.data.frame(pcoa$points)
sum_eig = sum(pcoa$eig)
eig_percent = round(pcoa$eig/sum_eig*100,1)
colnames(pcoa_points) <- paste0("PCoA", 1:3)
inter = intersect(rownames(meta), rownames(pcoa_points))
meta = meta[inter,]
pcoa_points = pcoa_points[inter,]
pcoa_result = cbind(meta, pcoa_points)
x=paste("PCoA 1 (", eig_percent[1], "%)", sep="")
y=paste("PCoA 2 (", eig_percent[2], "%)", sep="")
formula_str = paste("otu2~", .group)
formula_obj = stats::as.formula(formula_str)
div = vegan::adonis2(formula_obj, data = meta, permutations = 999, ...)
adonis = paste0("Adonis: R=",round(div$R2,3), "; p=",div$`Pr(>F)`)
temp = c(x,y,adonis)
.beta@temp = temp
.beta@meta = tibble::as_tibble(pcoa_result)
.beta@result = adonis[1]
} else if (type == 'nmds'){
utils::capture.output(df_nmds <-  vegan::metaMDS(dist, k = 3))
stress = df_nmds$stress
nmds_points = as.data.frame(df_nmds$points)
names(nmds_points)[1:2] <- c('NMDS1', 'NMDS2')
inter = intersect(rownames(meta), rownames(nmds_points))
meta = meta[inter,]
nmds_points = nmds_points[inter,]
nmds_result = cbind(meta, nmds_points)
adonis = paste('Stress=',round(stress, 3))
.beta@temp = adonis
.beta@meta = tibble::as_tibble(nmds_result)
.beta@result = adonis[1]
} else if (type == 'pca'){
pca = stats::prcomp(otu2, ...)
formula_str = paste("otu2~", .group)
formula_obj = stats::as.formula(formula_str)
div = vegan::adonis2(formula_obj, data = meta, permutations = 999, ...)
adonis = paste0("Adonis: R=",round(div$R2,3), "; p=",div$`Pr(>F)`)
pca_points = as.data.frame(pca$x)
inter = intersect(rownames(meta), rownames(pca_points))
meta = meta[inter,]
pca_points = pca_points[inter,]
pca_result = cbind(meta, pca_points)
summ1 = summary(pca)
x = paste0("PCA1(",round(summ1$importance[2,1]*100,2),"%)")
y = paste0("PCA2(",round(summ1$importance[2,2]*100,2),"%)")
temp = c(x, y, adonis)
.beta@temp = temp
.beta@meta = tibble::as_tibble(pca_result)
.beta@result = adonis[1]
} else{
stop("type should be one of 'pcoa', 'nmds' and 'pca'")
}
return(.beta)
}
nem_pcoa <- nem |> calc_beta(pcoa, Treatments, method = "bray")
nem_pcoa
nem_pcoa@meta
#' @slot temp A character vector of the difference comparison.
#'
#' @seealso
#' The constructor, \code{\link{calc_beta}}; Class for storing two-factor beta
#' diversity analysis, \code{\link{beta2-class}}; Visualization function,
#' \code{\link{nem_plot}}.
#'
#' @name beta-class
#' @rdname beta-class
#' @exportClass beta
methods::setClass("beta",
slots = list(
meta = "data.frame",
result = "character",
temp = "character"
))
methods::setMethod("show", "beta", function(object){
cat("This is an beta object\n")
print(object@meta)
print(object@temp)
print(object@result)
})
nem_pcoa <- nem |> calc_beta(pcoa, Treatments, method = "bray")
nem_pcoa
#' @slot temp A character vector of the difference comparison.
#'
#' @seealso
#' The constructor, \code{\link{calc_beta}}; Class for storing two-factor beta
#' diversity analysis, \code{\link{beta2-class}}; Visualization function,
#' \code{\link{nem_plot}}.
#'
#' @name beta-class
#' @rdname beta-class
#' @exportClass beta
methods::setClass("beta",
slots = list(
meta = "data.frame",
result = "character",
temp = "character"
))
methods::setMethod("show", "beta", function(object){
cat("This is an beta object\n")
print(object@meta)
cat("The result of the difference comparison is\n")
print(object@result)
})
library(devtools)
document()
rlang::last_trace()
document()
document()
library(devtool)
library(devtools)
document()
check()
?ggplot2::stat_ellipse
?ggplot2::`ggplot-class`
library(ggplot2)
### ** Examples
# Create a data frame with some sample data, then create a data frame
# containing the mean value for each group in the sample data.
set.seed(1)
sample_df <- data.frame(
group = factor(rep(letters[1:3], each = 10)),
value = rnorm(30)
)
group_means_df <- setNames(
aggregate(value ~ group, sample_df, mean),
c("group", "group_mean")
)
# The following three code blocks create the same graphic, each using one
# of the three patterns specified above. In each graphic, the sample data
# are plotted in the first layer and the group means data frame is used to
# plot larger red points on top of the sample data in the second layer.
# Pattern 1
# Both the `data` and `mapping` arguments are passed into the `ggplot()`
# call. Those arguments are omitted in the first `geom_point()` layer
# because they get passed along from the `ggplot()` call. Note that the
# second `geom_point()` layer re-uses the `x = group` aesthetic through
# that mechanism but overrides the y-position aesthetic.
ggplot(data = sample_df, mapping = aes(x = group, y = value)) +
geom_point() +
geom_point(
mapping = aes(y = group_mean), data = group_means_df,
colour = 'red', size = 3
)
### ** Examples
# Create a data frame with some sample data, then create a data frame
# containing the mean value for each group in the sample data.
set.seed(1)
sample_df <- data.frame(
group = factor(rep(letters[1:3], each = 10)),
value = rnorm(30)
)
group_means_df <- setNames(
aggregate(value ~ group, sample_df, mean),
c("group", "group_mean")
)
# The following three code blocks create the same graphic, each using one
# of the three patterns specified above. In each graphic, the sample data
# are plotted in the first layer and the group means data frame is used to
# plot larger red points on top of the sample data in the second layer.
# Pattern 1
# Both the `data` and `mapping` arguments are passed into the `ggplot()`
# call. Those arguments are omitted in the first `geom_point()` layer
# because they get passed along from the `ggplot()` call. Note that the
# second `geom_point()` layer re-uses the `x = group` aesthetic through
# that mechanism but overrides the y-position aesthetic.
hehe = ggplot(data = sample_df, mapping = aes(x = group, y = value)) +
geom_point() +
geom_point(
mapping = aes(y = group_mean), data = group_means_df,
colour = 'red', size = 3
)
class(hehe)
?`gg`
?gg
?ggplot
str(hehe)
detach("package:ggplot2", unload = TRUE)
detach("package:easynem", unload = TRUE)
library(devtools)
document()
check()
document()
check()
document()
check()
document()
check()
document()
check()
document()
check()
document()
check(\)
check()
check()
document()
check()
document()
check()
document()
check()
document()
check()
check()
document()
check()
document()
check()
check()
check()
library(devtools)
document()
check()
document()
check()
detach("package:easynem", unload = TRUE)
library(devtools)
document()
check()
